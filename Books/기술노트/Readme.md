## 프로세스와 스레드
### 프로세스
- **정의:** 프로세스는 운영 체제에서 실행되는 프로그램의 인스턴스입니다. 각 프로세스는 독립된 메모리 공간을 가지며, 실행 중인 프로그램의 상태를 나타냅니다.
- **메모리 공유:** 각 프로세스는 독립된 메모리 공간을 가지므로, 서로 다른 프로세스 간에는 메모리를 공유하지 않습니다.
- **생성 속도:** 프로세스 생성에는 많은 비용이 소요됩니다. 새로운 프로세스를 생성할 때는 프로세스의 복사본을 만들어야 하므로 시간과 자원이 많이 필요합니다.
- **스위칭 비용:** 프로세스 간의 전환은 컨텍스트 스위칭이 필요하며, 이는 비용이 많이 듭니다. 각 프로세스는 독립된 메모리 공간을 가지고 있기 때문에 전환 시 메모리 매핑과 상태 저장 등의 작업이 필요합니다.

### 스레드
- **정의:** 스레드는 프로세스 내에서 실행되는 작은 실행 단위입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다.
- **메모리 공유:** 스레드는 같은 프로세스 내에서 실행되므로, 프로세스의 메모리를 공유합니다. 이는 데이터를 공유하고 효율적인 통신을 가능케 합니다.
- **생성 속도:** 스레드는 프로세스 내에서 생성되며, 프로세스의 자원을 공유하기 때문에 스레드를 생성하는 데 필요한 비용이 적습니다.
- **스위칭 비용:** 스레드 간의 전환은 상대적으로 더 빠르며 경량입니다. 스레드는 같은 프로세스 내에서 실행되므로, 전환 시에는 스택과 레지스터 값만 변경하면 되므로 프로세스 전환보다 적은 비용이 듭니다.

## 동시성과 병렬성
### 동시성(Concurrency)
- **정의:** 동시성은 여러 작업이 동시에 진행되는 것처럼 보이는 개념을 나타냅니다. 실제로는 여러 작업이 동시에 실행되는 것이 아니라, 작업 간의 빠른 전환을 통해 동시에 실행되는 것처럼 보입니다.
- **예시:** 다중 프로세스 또는 다중 스레드를 사용하여 여러 작업을 동시에 처리할 수 있습니다. 예를 들어, 웹 서버는 여러 클라이언트 요청을 동시에 처리하기 위해 다중 스레드를 사용할 수 있습니다.
- **주요 특징:**
  - 동시성은 시스템의 반응성을 향상시키고 작업 처리량을 증가시킬 수 있습니다.
  - 다양한 동기화 기술을 사용하여 공유 자원에 대한 안전한 접근을 보장해야 합니다.

### 병렬성(Parallelism)
- **정의:** 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 나타냅니다. 하나의 작업을 여러 개의 하위 작업으로 분할하고, 이를 동시에 처리함으로써 병렬성을 달성할 수 있습니다.
- **예시:** 멀티코어 프로세서를 사용하여 하나의 프로그램을 동시에 여러 개의 스레드로 실행하거나, 여러 대의 컴퓨터를 클러스터로 구성하여 작업을 분산하는 등의 방법으로 병렬성을 달성할 수 있습니다.
- **주요 특징:**
  - 병렬성은 작업을 동시에 실행함으로써 처리 시간을 단축하고 성능을 향상시킬 수 있습니다.
  - 공유 자원에 대한 경합 상태나 동기화 문제를 피하기 위해 조심해야 합니다.

### 요약
- 동시성은 여러 작업을 동시에 실행되는 것처럼 보이게 만들어 시스템의 반응성을 향상시키고 처리량을 증가시킵니다.
- 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 나타내며, 처리 시간을 단축하고 성능을 향상시킵니다.
- 동시성과 병렬성은 서로 다른 개념이지만, 종종 함께 사용되어 병렬화된 동시성(concurrent parallelism)을 구현하는 데 사용됩니다.

## 데드락(Deadlock)
멀티스레드 또는 멀티프로세스 환경에서 발생하는 중요한 문제 중 하나입니다. 데드락은 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리며 진행하지 못하는 상태를 말합니다. 이러한 상황에서는 각 작업이 다른 작업이 끝나기를 기다리면서 서로를 블록시키고 있어, 시스템이 더 이상 진행할 수 없게 됩니다.

### 데드락 발생 4가지 조건
- **상호 배제(Mutual Exclusion):** 리소스에 대한 동시 접근이 허용되지 않아야 합니다. 즉, 한 번에 하나의 프로세스만 리소스에 접근할 수 있어야 합니다.
- **보유 및 대기(Hold and Wait):** 프로세스가 이미 어떤 리소스를 보유한 상태에서 다른 리소스를 얻기 위해 대기하는 경우입니다.
- **비선점(No Preemption):** 어떤 프로세스가 이미 어떤 리소스를 보유하고 있을 때, 그 리소스를 다른 프로세스가 선점할 수 없어야 합니다. 리소스는 해당 프로세스가 자발적으로 릴리스할 때만 다른 프로세스에게 넘어갑니다.
- **순환 대기(Circular Wait):** 프로세스 집합 {P1, P2, ..., Pn}에서, P1은 P2가 보유한 리소스를 대기하고, P2는 P3가 보유한 리소스를 대기하는 식으로, Pn은 P1이 보유한 리소스를 대기하는 상황입니다.

### 데드락을 방지하거나 해결하기 위한 전략
- **상호 배제를 해제:** 리소스에 대한 동시 접근을 허용하거나, 특정 조건에서만 상호 배제를 적용합니다. 이 방법은 데드락을 방지할 수 있지만, 다른 문제를 야기할 수도 있습니다.
- **보유 및 대기를 방지:** 프로세스가 모든 필요한 리소스를 한 번에 얻을 수 있도록 설계합니다. 이를 위해 리소스를 예약하거나, 리소스를 보유하지 않은 상태에서 다른 리소스를 요청할 수 있도록 하는 등의 방법을 사용할 수 있습니다.
- **비선점:** 리소스 선점 기능을 추가하여, 다른 프로세스가 필요한 리소스를 강제로 빼앗을 수 있도록 합니다. 이는 일부 시스템에서는 적용하기 어려울 수 있습니다.
- **순환 대기 방지:** 리소스 요청 순서를 정하여 순환 대기를 방지하거나, 리소스를 할당할 때 우선순위를 부여하여 순환 대기를 예방할 수 있습니다.

## 트랜잭션 격리 레벨
트랜잭션 격리 레벨은 동시에 여러 트랜잭션이 발생할 때 데이터베이스 시스템에서 트랜잭션 간의 상호 작용을 제어하는 방법을 나타냅니다. 데이터베이스에서 일반적으로 네 가지 격리 레벨이 정의되어 있습니다. 각 레벨은 트랜잭션 간의 일관성, 격리 수준, 성능 등을 다르게 보장합니다. 이러한 격리 레벨은 ANSI/ISO SQL 표준에 따라 정의되며, 다음과 같습니다:

### Read Uncommitted (미커밋 읽기)
- 가장 낮은 격리 레벨로, 다른 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있습니다.
- 이 격리 레벨에서는 Dirty Read(더티 리드), Non-Repeatable Read(반복되지 않는 읽기), Phantom Read(유령 읽기)와 같은 문제가 발생할 수 있습니다.

### Read Committed (커밋된 읽기) - Oracle, MsSQL
- 트랜잭션이 커밋된 데이터만 읽을 수 있습니다. 이러한 레벨에서는 Dirty Read는 방지됩니다.
- 하지만 Non-Repeatable Read와 Phantom Read는 발생할 수 있습니다.

### Repeatable Read (반복 가능한 읽기) - MySQL
- 트랜잭션 내에서 동일한 쿼리를 여러 번 실행하더라도 항상 동일한 결과가 나타납니다. 즉, 다른 트랜잭션이 해당 트랜잭션의 데이터를 변경할 수 없습니다.
- 이 격리 레벨에서는 Dirty Read와 Non-Repeatable Read는 방지됩니다. 하지만 Phantom Read는 발생할 수 있습니다.

### Serializable (직렬화 가능)
- 가장 높은 격리 레벨로, 동시성을 완전히 차단하여 동시에 두 개 이상의 트랜잭션이 실행되지 않습니다.
- 이 격리 레벨에서는 Dirty Read, Non-Repeatable Read, Phantom Read가 모두 방지됩니다.

데이터베이스 시스템에서는 이러한 격리 레벨 중 하나를 선택하여 트랜잭션의 일관성과 동시성을 적절히 조절합니다. 레벨을 선택할 때는 데이터베이스 시스템의 요구 사항, 데이터 무결성, 일관성, 성능 등을 고려해야 합니다. 더 높은 격리 레벨은 데이터 무결성을 보다 확실히 보장하지만, 동시성에 대한 성능 저하가 발생할 수 있습니다.

## 트랜잭션 락(Transaction Lock)
데이터베이스 트랜잭션이 데이터에 대한 액세스를 제어하는 메커니즘입니다. 트랜잭션 락은 다른 트랜잭션이 동시에 동일한 데이터를 수정하거나 액세스하지 못하도록 보장하여 데이터의 일관성과 무결성을 유지합니다.

### 트랜잭션 락 종류
- **읽기 락(Read Lock):** 트랜잭션이 데이터를 읽을 때 사용됩니다. 읽기 락이 설정되어 있으면 다른 트랜잭션은 해당 데이터를 수정할 수 없습니다. 여러 트랜잭션이 동시에 동일한 데이터를 읽을 수 있습니다.
- **쓰기 락(Write Lock):** 트랜잭션이 데이터를 수정할 때 사용됩니다. 쓰기 락이 설정되어 있으면 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없습니다. 여러 트랜잭션이 동시에 동일한 데이터를 수정할 수 없습니다.
- **공유 락(Shared Lock):** 여러 트랜잭션이 동시에 데이터를 읽을 수 있지만, 쓰기 락을 설정한 트랜잭션이 존재하면 쓰기 락이 해제될 때까지 데이터를 수정할 수 없습니다.
- **배타적 락(Exclusive Lock):** 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없습니다.
데이터베이스 시스템은 이러한 락을 사용하여 동시성 제어를 관리합니다. 트랜잭션은 데이터를 액세스하기 전에 해당 데이터에 대한 적절한 락을 얻어야 합니다. 만약 다른 트랜잭션이 이미 해당 데이터에 대한 락을 보유하고 있다면, 트랜잭션은 락이 해제될 때까지 대기하게 됩니다. 이를 통해 데이터베이스 시스템은 여러 트랜잭션이 동시에 데이터를 수정할 때 발생할 수 있는 일관성과 무결성 문제를 방지합니다.

### DROP
- **정의:** DROP 문은 테이블 자체를 삭제하는 데 사용됩니다. 즉, 테이블의 구조와 함께 테이블의 모든 데이터가 삭제됩니다.
- **영향:** DROP 문을 사용하면 테이블과 그 안의 모든 데이터가 영구적으로 삭제됩니다. 데이터베이스에서 테이블이 완전히 사라지게 됩니다.
- **롤백:** DROP 문은 롤백되지 않습니다. 즉, 트랜잭션이 롤백되더라도 테이블이 삭제된 상태로 남아 있습니다.

### TRUNCATE
- **정의:** TRUNCATE 문은 테이블의 모든 데이터를 삭제하지만, 테이블의 구조는 유지됩니다.
- **영향:** TRUNCATE 문을 사용하면 테이블의 모든 데이터가 삭제되지만, 테이블 자체는 남아 있습니다.
- **롤백:** TRUNCATE 문은 롤백될 수 있습니다. 트랜잭션이 롤백되면 TRUNCATE된 데이터가 복구됩니다. 하지만 몇몇 데이터베이스 관리 시스템에서는 롤백이 지원되지 않을 수도 있습니다.

`DROP`은 테이블 자체를 삭제하고 그 안의 모든 데이터를 삭제합니다. 테이블 자체가 완전히 사라지며 롤백되지 않습니다.
`TRUNCATE`는 테이블의 데이터를 삭제하지만, 테이블 자체는 유지됩니다. 롤백될 수 있으며, 롤백 시 삭제된 데이터가 복구될 수 있습니다.

## JPA(Java Persistence API) 1차 캐시(First Level Cache)와 2차 캐시(Second Level Cache)
### 1차 캐시(First Level Cache)
- **정의:** 1차 캐시는 엔티티 매니저 내에 존재하는 캐시로, 엔티티 매니저가 특정 트랜잭션 내에서 관리하는 영역입니다. 각각의 엔티티 매니저 인스턴스마다 독립적으로 관리되며, 특정 엔티티 매니저가 로드한 엔티티는 해당 엔티티 매니저 내에서 캐시됩니다.
- **스코프:** 엔티티 매니저의 트랜잭션 범위 내에서만 유효합니다. 트랜잭션이 커밋되거나 롤백되면 1차 캐시도 함께 비워집니다.
- **장점:** 같은 트랜잭션 내에서 같은 엔티티를 여러 번 조회할 경우, 1차 캐시에서 해당 엔티티를 바로 반환하여 데이터베이스에 추가적인 조회를 하지 않아도 됩니다.

### 2차 캐시(Second Level Cache)
- **정의:** 2차 캐시는 여러 엔티티 매니저 간에 공유되는 캐시로, 여러 트랜잭션 또는 엔티티 매니저 간에 공유할 수 있습니다. 따라서 2차 캐시에 저장된 엔티티는 여러 엔티티 매니저 간에 공유되어 조회될 수 있습니다.
- **스코프:** 애플리케이션 전체에서 유효합니다. 엔티티 매니저 간에 공유되므로 같은 엔티티가 여러 번 로드되더라도 데이터베이스에 추가적인 조회를 하지 않을 수 있습니다.
- **장점:** 네트워크 오버헤드를 줄일 수 있으며, 동일한 엔티티를 여러 번 조회할 때 쿼리를 다시 실행하지 않고 캐시된 엔티티를 반환하여 성능을 향상시킵니다.

### 요약
- 1차 캐시는 엔티티 매니저의 트랜잭션 범위 내에서 동작하며, 엔티티 매니저 간에 공유되지 않습니다.
- 2차 캐시는 애플리케이션 전체에서 동작하며, 여러 엔티티 매니저 간에 공유됩니다. 따라서 네트워크 오버헤드를 줄이고 성능을 향상시킬 수 있습니다.

## OSIV(Open Session In View)
JPA(Java Persistence API)를 사용하는 웹 애플리케이션에서 사용되는 패턴입니다. OSIV 패턴은 HTTP 요청의 라이프사이클 동안 JPA 세션(또는 엔티티 매니저)을 열어두고, 뷰 렌더링까지 세션을 유지하는 방식입니다.

일반적으로 웹 애플리케이션에서는 HTTP 요청이 발생하면 해당 요청을 처리하기 위한 JPA 세션이 열리고, 요청이 완료되면 세션이 닫히는 것이 보통입니다. 그러나 OSIV 패턴을 사용하면 HTTP 요청의 처리 과정 동안 JPA 세션이 유지되어, 해당 요청에서 발생한 엔티티의 로딩과 관련된 모든 작업을 수행할 수 있습니다.

### OSIV 패턴의 주요 특징
- **지연로딩(Lazy Loading) 사용:** OSIV 패턴을 사용하면 뷰 렌더링 단계에서도 엔티티를 로딩할 수 있습니다. 이는 지연로딩이 사용되는 경우에도 뷰에서 필요한 엔티티를 로딩할 수 있게 해줍니다.
- **트랜잭션 범위 확장:** 일반적으로 JPA 세션은 트랜잭션 범위 내에서만 유효하지만, OSIV 패턴을 사용하면 HTTP 요청의 전체 라이프사이클 동안 세션을 유지할 수 있습니다.
- **View와 로직의 분리 유지:** OSIV 패턴을 사용하면 뷰 렌더링 과정에서도 엔티티를 로딩할 수 있으므로, View와 비즈니스 로직을 명확하게 분리할 수 있습니다.
- 
OSIV 패턴은 편리하게 사용할 수 있지만, 신중하게 사용해야 합니다. 잘못 사용하면 지연로딩을 트랜잭션 밖에서 수행하게 되어 LazyInitializationException과 같은 문제가 발생할 수 있습니다. 또한 OSIV 패턴은 세션을 오래 유지하기 때문에 메모리 누수와 같은 부작용이 발생할 수 있으므로 주의가 필요합니다.

## N+1 문제
부모 엔티티들을 가져온 후, 각각의 부모 엔티티에 대해 추가적인 쿼리를 실행하여 연관된 자식 엔티티를 로딩합니다. 이 때, 각 부모 엔티티당 하나의 쿼리가 추가로 실행됩니다. 이 때문에 "N+1"이라는 용어가 사용됩니다.
이러한 N+1 문제는 다음과 같은 상황에서 특히 빈번하게 발생할 수 있습니다.

- 연관된 엔티티를 지연 로딩으로 설정한 경우
- 엔티티 그래프 또는 패치 조인(fetch join)을 사용하지 않고 연관된 엔티티를 로딩하는 경우
- 엔티티 그래프나 패치 조인을 사용했지만, 그것이 올바르게 설정되지 않은 경우

### N+1 문제를 해결하기 위한 몇 가지 방법
- 엔티티 그래프 또는 패치 조인 사용: 엔티티 그래프나 패치 조인을 사용하여 쿼리를 통해 한 번에 연관된 엔티티를 함께 로딩할 수 있습니다. 이를 통해 추가적인 쿼리 실행 없이 모든 데이터를 한 번에 가져올 수 있습니다.
- 일괄 로딩(Batch Loading) 사용: 일괄 로딩은 일괄 처리 방식으로 데이터를 가져오는 기능입니다. 이를 통해 여러 엔티티를 한 번에 로딩하여 N+1 문제를 방지할 수 있습니다.
- 캐시 사용: 캐시를 사용하여 자주 사용되는 데이터를 메모리에 저장하여 추가적인 쿼리를 방지할 수 있습니다. 하지만 이 방법은 캐시의 유효성과 관리에 주의해야 합니다.

## JPQL(Java Persistence Query Language):
JPQL은 JPA(Java Persistence API)의 일부로 제공되는 쿼리 언어입니다. 엔티티와 연관된 데이터를 조회하거나 조작하기 위해 사용됩니다. SQL과 유사하지만, 엔티티 객체와 속성을 대상으로 하는 객체지향 쿼리 언어입니다.

### 특징
- 엔티티 객체와 그와 연관된 테이블에 직접 접근합니다.
- 문자열 기반의 쿼리를 작성하며, 정적인 쿼리입니다.
- 데이터베이스 종류에 따라 일부 기능이나 표현식이 제한될 수 있습니다.

## QueryDSL
QueryDSL은 자바 코드를 사용하여 유연하고 안전한 쿼리를 작성하기 위한 프레임워크입니다. JPQL, SQL과 같은 문자열 기반의 쿼리보다 자바 코드로 쿼리를 작성할 수 있으며, 컴파일 시점에 타입 안정성을 보장합니다.

### 특징
- 자바 코드를 사용하여 쿼리를 작성합니다.
- 컴파일 시점에 타입 안정성을 보장하여 오타나 잘못된 쿼리를 런타임에서 발견할 수 있습니다.
- 코드 자동완성 및 IDE 지원이 용이하며, 더 깔끔하고 가독성이 좋은 쿼리를 작성할 수 있습니다.
- JPQL이나 SQL보다 유연하고 표현력이 좋으며, 동적으로 쿼리를 생성하는 데 유용합니다.

### 차이점
- **문자열 기반 vs 자바 코드 기반:** JPQL은 문자열 기반의 쿼리 언어이며, QueryDSL은 자바 코드를 사용하여 쿼리를 작성합니다.
- **타입 안정성:** QueryDSL은 컴파일 시점에 타입 안정성을 제공하여 더 안전한 쿼리 작성을 도와줍니다.
- **표현력과 유연성:** QueryDSL이 JPQL보다 더 풍부한 표현력과 유연성을 제공하여 동적인 쿼리 작성이 용이합니다.
일반적으로 QueryDSL은 JPQL보다 더 유연하고 안전하며 가독성이 좋은 쿼리를 작성하는 데 사용됩니다. 그러나 선택은 프로젝트의 요구사항과 개발자의 선호도에 따라 다를 수 있습니다.

## Map
Map은 키(key)와 값(value)의 쌍으로 데이터를 저장하는 자료구조입니다. 각 키는 고유해야 하며, 키를 사용하여 값을 조회하거나 추가할 수 있습니다.
### 특징
- 순서가 없는 자료구조입니다. 따라서 데이터의 순서는 보장되지 않습니다.
- 키는 중복될 수 없지만, 값은 중복될 수 있습니다.
- 주로 검색, 조회, 매핑 등의 작업에 사용됩니다.
- 구현 클래스: HashMap, TreeMap, LinkedHashMap 등이 있습니다.

## Set
Set은 중복을 허용하지 않는 데이터의 모음입니다. 모든 요소는 고유해야 하며, 순서는 보장되지 않습니다.
### 특징
- 중복된 요소를 허용하지 않습니다. 따라서 모든 요소는 고유해야 합니다.
- 순서가 없는 자료구조이며, 요소의 저장 순서는 보장되지 않습니다.
- 주로 중복을 제거하거나 멤버십 테스트 등에 사용됩니다.
- 구현 클래스: HashSet, TreeSet 등이 있습니다.

## List
List는 순서가 있는 데이터의 모음입니다. 요소들은 인덱스(index)로 접근할 수 있으며, 중복된 요소를 허용합니다.
### 특징
- 요소들의 저장 순서가 유지되며, 요소는 인덱스로 접근할 수 있습니다.
- 중복된 요소를 허용합니다.
- 주로 순차적인 접근, 반복 작업 등에 사용됩니다.
- 구현 클래스: ArrayList, LinkedList, Vector 등이 있습니다.

## HashMap
- 동기화: 동기화를 지원하지 않음
- Null 허용: 키(key)와 값(value)으로 null을 허용함
- 성능: 단일 스레드 환경에서 더 높은 성능을 제공함
- Iterator: Iterator는 fail-fast 특성을 가짐
- 상속: AbstractMap 클래스를 상속받음
- 속도: 빠른 속도를 가짐

## HashTable
- 동기화: 내장된 동기화로 멀티스레드 환경에서 안전함
- Null 허용: 키(key)와 값(value)으로 null을 허용하지 않음
- 성능: 동기화 오버헤드로 인해 성능이 더 낮을 수 있음
- Enumeration: Enumeration은 fail-safe 특성을 가짐
- 상속: Dictionary 클래스를 상속받음
- 안정성: 멀티스레드 환경에서 안정적으로 동작함

HashMap은 성능이 뛰어나고 null을 허용하며 동기화를 지원하지 않습니다. 반면에 HashTable은 멀티스레드 환경에서 안전하고 null을 허용하지 않으며 동기화를 내장하고 있습니다. 일반적으로는 HashMap을 사용하는 것이 더 권장되지만, 멀티스레드 환경에서는 HashTable을 고려해야 합니다. 그러나 최신 자바 버전에서는 `ConcurrentHashMap`을 사용하는 것이 일반적으로 더 좋은 선택입니다.

## 트리(Tree)와 힙(Heap)
둘 다 자료구조로, 데이터를 저장하고 관리하는 데 사용됩니다. 그러나 각각의 구조와 특징은 다릅니다.

### 트리(Tree)
트리는 계층적인 구조로 데이터를 저장하는 자료구조입니다. 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다.

### 특징
- 각 노드는 하나의 부모 노드를 가집니다. 루트 노드를 제외한 모든 노드는 부모 노드를 가집니다.
- 트리는 순환 구조가 아닙니다. 즉, 어떤 노드에서 출발하여 재귀적으로 자기 자신에게 도달할 수 없습니다.
- 이진 트리(Binary Tree)는 각 노드가 최대 두 개의 자식을 가지는 트리입니다.
- 트리는 탐색(Search)이나 정렬(Sorting)과 같은 작업에 사용됩니다.
  
### 구현
이진 트리(Binary Tree), 이진 탐색 트리(Binary Search Tree), AVL 트리, 레드-블랙 트리 등이 있습니다.

### 힙(Heap):
힙은 완전 이진 트리(Complete Binary Tree)를 기반으로 한 자료구조로, 최댓값이나 최솟값을 빠르게 찾기 위해 사용됩니다.

### 특징
- 힙은 완전 이진 트리이므로 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨은 왼쪽부터 차례대로 채워져야 합니다.
- 최대 힙(Max Heap)은 부모 노드가 자식 노드보다 크거나 같은 값을 가지는 힙입니다. 최솟값을 빠르게 찾을 수 있습니다.
- 최소 힙(Min Heap)은 부모 노드가 자식 노드보다 작거나 같은 값을 가지는 힙입니다. 최댓값을 빠르게 찾을 수 있습니다.
  
### 구현
배열을 기반으로 구현됩니다. 완전 이진 트리의 특성을 이용하여 배열의 인덱스를 활용하여 자식 노드와 부모 노드를 쉽게 찾을 수 있습니다.

### 요약
트리는 계층적인 구조로 데이터를 저장하고 관리하는 데 사용되며, 탐색이나 정렬과 같은 작업에 사용됩니다.
힙은 완전 이진 트리를 기반으로 한 자료구조로, 최댓값이나 최솟값을 빠르게 찾기 위해 사용됩니다.

### 기본키(Primary Key)
기본키는 테이블의 각 레코드를 유일하게 식별하는 데 사용되는 열(또는 열의 조합)입니다. 기본키는 NULL 값을 가질 수 없으며, 테이블 내에서 고유해야 합니다.

### 특징
- 각 테이블은 하나의 기본키를 가져야 합니다.
- 기본키로 지정된 열은 레코드를 식별하는 데 사용되며, 검색 및 정렬에 사용됩니다.
- 기본키는 일반적으로 유일한 값이어야 하며, 자동 증가하는 숫자(auto-increment) 또는 UUID(UUID)와 같은 값을 사용할 수 있습니다.
 
### 외래키(Foreign Key)
외래키는 다른 테이블의 기본키를 참조하는 열입니다. 즉, 다른 테이블의 레코드를 식별하는 데 사용됩니다.

### 특징
- 외래키는 다른 테이블의 기본키와 관계를 나타냅니다.
- 외래키 제약 조건은 데이터 무결성을 유지하는 데 중요한 역할을 합니다. 즉, 외래키 값은 참조하는 테이블의 기본키 값이어야 합니다.
- 외래키 제약 조건을 통해 참조 무결성을 유지할 수 있으며, 외래키에 값을 삽입 또는 업데이트할 때 참조 무결성 제약을 준수해야 합니다.

### 복합 키(Composite Key)
복합 키는 둘 이상의 열의 조합으로 이루어진 기본키입니다. 즉, 하나의 열로만 유일한 식별이 불가능한 경우에 사용됩니다.

### 특징:
- 복합 키는 둘 이상의 열을 결합하여 유일한 식별자로 사용됩니다.
- 여러 열의 조합으로 인해 각 열의 값만으로는 유일성을 보장할 수 없는 경우에 사용됩니다.
- 복합 키를 사용할 때는 각 열의 조합이 유일한지 확인해야 하며, 데이터베이스 시스템에 따라 제약 조건을 추가하여 유일성을 보장할 수 있습니다.

### Mutable(가변)
Mutable 객체는 생성된 후에 그 상태를 변경할 수 있는 객체입니다. 즉, 객체의 내부 상태가 변경될 수 있습니다.

### 특징
- 객체의 내부 상태를 변경할 수 있으므로 상태가 동적으로 변할 수 있습니다.
- 여러 스레드가 동시에 접근하거나 변경할 경우 동기화 문제가 발생할 수 있습니다.
- 주로 변경 가능한 데이터 구조(예: 리스트, 맵) 등에 사용됩니다.

### Immutable(불변)
Immutable 객체는 생성된 후에 그 상태를 변경할 수 없는 객체입니다. 즉, 객체의 내부 상태는 변하지 않습니다.

### 특징
- 객체의 내부 상태를 변경할 수 없으므로 상태가 고정되어 있습니다.
- 동시성 문제나 스레드 안전성에 대해 걱정할 필요가 없습니다.
- 객체를 안전하게 공유하거나 캐싱하는 데 유용합니다.
- 주로 불변의 값 객체(예: 문자열, 숫자, 불리언)나 불변의 데이터 구조(예: 튜플, 세트) 등에 사용됩니다.

### 가변 vs 불변
- 가변 객체는 내부 상태를 변경할 수 있으므로 상태에 따라 동적으로 변할 수 있습니다. 이에 반해, 불변 객체는 내부 상태가 변하지 않으므로 안전하게 공유하거나 사용할 수 있습니다.
- 가변 객체는 상태 변경이 가능하기 때문에 부작용이 발생할 수 있습니다. 반면에 불변 객체는 상태 변경이 불가능하기 때문에 부작용이 없고 예측 가능합니다.
- 불변 객체는 함수형 프로그래밍에서 주로 사용되며, 가변 객체는 상태 변화를 추적하고 관리해야 하는 경우에 사용됩니다.
- 가변 객체와 불변 객체의 선택은 프로그램의 요구사항과 설계 목표에 따라 달라집니다. 보통은 변경되지 않는 데이터나 상태를 불변 객체로 표현하여 안전성과 예측 가능성을 높이는 것이 바람직합니다.

### 쿠키(Cookie)
쿠키는 클라이언트의 로컬 브라우저에 저장되는 작은 데이터 조각입니다. 서버에서 클라이언트에게 전달되어 클라이언트의 로컬에 저장된 후, 이후에 같은 서버로 요청이 전송될 때 함께 전송됩니다.

### 특징
- 클라이언트 측에서 관리되며, 서버로 전송되는 HTTP 요청의 헤더에 포함됩니다.
- 주로 클라이언트의 상태 정보를 유지하고 식별하기 위해 사용됩니다. 예를 들어 로그인 정보, 사용자 설정 등을 저장할 수 있습니다.
- 클라이언트가 쿠키를 삭제하거나 만료일이 지나면 삭제됩니다.
- 
### 세션(Session)
세션은 서버 측에서 유지되는 클라이언트의 상태 정보를 저장하는 데 사용되는 데이터 저장 공간입니다. 세션은 클라이언트의 브라우저에 저장되는 쿠키를 사용하여 세션 식별자를 클라이언트에게 전달하고, 서버 측에서는 이 식별자를 사용하여 상태 정보를 관리합니다.

### 특징
- 서버 측에서 관리되며, 클라이언트에게는 세션 식별자(session ID)만 전달됩니다.
- 주로 사용자의 로그인 상태를 유지하고 세션별 상태 정보를 저장하는 데 사용됩니다.
- 일반적으로 쿠키를 사용하여 세션 식별자를 클라이언트에게 전달하고, 서버에서는 세션 관리자를 통해 세션 정보를 관리합니다.

### 차이점
- 위치: 쿠키는 클라이언트의 로컬 브라우저에 저장되고 관리되며, 세션은 서버 측에서 유지 및 관리됩니다.
- 데이터 저장: 쿠키는 작은 데이터 조각을 클라이언트에 저장하는 데 사용되고, 세션은 서버에 클라이언트의 상태 정보를 저장하는 데 사용됩니다.
- 수명: 쿠키는 만료일을 설정하여 지속적으로 유지할 수 있고, 세션은 클라이언트의 브라우저가 닫히거나 세션 타임아웃이 지나면 삭제됩니다.
보통은 로그인 상태와 사용자 설정과 같은 중요한 정보를 세션에 저장하고, 세션 식별자를 쿠키를 통해 클라이언트에게 전달하여 세션을 유지하고 관리합니다

### 세션 스토리지(Session Storage)
클라이언트 측 웹 스토리지 메커니즘 중 하나로, 웹 브라우저에 데이터를 저장하는 방법 중 하나입니다. 세션 스토리지는 sessionStorage 객체를 사용하여 데이터를 저장하며, 이는 브라우저 세션 동안에만 유지됩니다.

### 특징
- **브라우저 세션 동안 유지:** 세션 스토리지에 저장된 데이터는 브라우저 세션이 유지되는 동안에만 유효합니다. 즉, 사용자가 브라우저를 닫거나 탭을 닫으면 데이터가 삭제됩니다.
- **도메인별로 분리:** 각 도메인은 자체 세션 스토리지를 가지며, 동일한 도메인에서 실행되는 모든 페이지에서 접근할 수 있습니다.
- **서버와 독립적:** 세션 스토리지는 서버와 독립적으로 동작하며, 서버와의 통신 없이 브라우저 내에서 데이터를 저장하고 관리할 수 있습니다.
- **용량 제한:** 일반적으로 브라우저마다 세션 스토리지에 저장할 수 있는 데이터의 용량이 제한되어 있습니다. 이러한 용량 제한은 브라우저의 설정이나 정책에 따라 다를 수 있습니다.
- **보안:** 세션 스토리지는 동일한 보안 정책을 따르며, 일반적으로 HTTPS를 통해 전송된 데이터는 안전하게 저장됩니다.
세션 스토리지는 주로 임시 데이터나 세션 관련 정보와 같이 브라우저 세션 동안에만 필요한 데이터를 저장하는 데 사용됩니다. 사용자 인증 토큰, 장바구니 정보, 사용자 설정 등을 세션 스토리지에 저장하여 웹 애플리케이션의 세션 관리를 용이하게 할 수 있습니다.

### IOC (Inversion of Control)
IOC는 제어의 역전이라고도 하며, 일반적으로 프레임워크가 애플리케이션의 흐름을 제어하고 애플리케이션 코드가 프레임워크에 의해 호출되는 제어 방식을 의미합니다. 즉, 일반적인 흐름이 단순히 애플리케이션 코드에서 프레임워크로 이동하는 것이 아니라, 프레임워크가 애플리케이션 코드를 호출하고 제어 흐름을 정의합니다.

### 특징
- 프레임워크가 애플리케이션의 제어 흐름을 관리하며, 개발자가 코드를 제어하는 대신 프레임워크에게 제어의 권한을 위임합니다.
- 이로써 코드의 결합도가 낮아지고, 유연성과 재사용성이 향상됩니다.
- 일반적으로 IOC를 구현하는 방법으로는 DI (의존성 주입)이 사용됩니다.

### DI (Dependency Injection)
DI는 의존성 주입이라고도 하며, 객체가 필요로 하는 의존성을 외부에서 주입받는 것을 의미합니다. 즉, 객체가 직접 필요한 의존 객체를 생성하거나 관리하지 않고, 외부에서 주입받아 사용합니다.

### 특징
- 객체의 의존성을 외부에서 주입받기 때문에 객체간의 결합도가 낮아지고, 코드의 재사용성과 테스트 용이성이 향상됩니다.
- 주입되는 의존 객체는 인터페이스를 통해 주입되며, 이를 통해 객체 간의 교체가 용이해집니다.
- 주로 생성자 주입(Constructor Injection), 세터 주입(Setter Injection), 필드 주입(Field Injection) 등의 방법으로 구현됩니다.

### 필터(Filter)
필터는 웹 애플리케이션에서 클라이언트의 HTTP 요청과 서버의 HTTP 응답에 대해 처리하는 역할을 담당하는 객체입니다. 필터는 서블릿 컨테이너 내부에 구현되며, 클라이언트의 요청이 서블릿에 도달하기 전 또는 서블릿이 응답을 보내기 전에 요청이나 응답을 수정하거나 확인할 수 있습니다.

### 특징
- 서블릿의 앞단에서 요청을 가로채거나 응답을 처리할 수 있습니다.
- 주로 요청과 응답에 대한 필터링, 인코딩, 로깅, 인증, 권한 부여 등의 작업에 사용됩니다.
- 서블릿 컨테이너에서 구현되므로 모든 서블릿에서 공통적으로 적용될 수 있습니다.

### 인터셉터(Interceptor)
인터셉터는 주로 스프링 프레임워크와 관련하여 사용되는 개념으로, 스프링의 MVC 구조에서 컨트롤러의 호출 전후에 실행되는 컴포넌트입니다. 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전에 요청을 가로채고, 컨트롤러가 응답을 생성한 후에 응답을 가로채는 역할을 합니다.

### 특징
- 스프링 프레임워크에서 제공하는 기능으로, 주로 스프링 MVC에서 사용됩니다.
- 주로 요청 전처리, 후처리, 로깅, 보안, 트랜잭션 관리 등의 작업에 사용됩니다.
- 스프링의 ApplicationContext 내부에서 동작하며, 스프링 빈으로 등록된 컴포넌트입니다.

### 차이점
- **구현 위치:** 필터는 서블릿 컨테이너 내부에서 구현되며, 모든 서블릿에서 공통적으로 적용될 수 있습니다. 반면에 인터셉터는 주로 스프링 프레임워크의 MVC에서 사용되며, 스프링의 ApplicationContext 내부에서 구현되고 관리됩니다.
- **적용 시점:** 필터는 서블릿의 앞단에서 요청을 가로채거나 응답을 처리합니다. 반면에 인터셉터는 주로 컨트롤러의 호출 전후에 실행되는 컴포넌트로서, 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전과 후에 실행됩니다.
- **목적:** 필터는 요청과 응답에 대한 필터링, 인코딩, 로깅, 인증, 권한 부여 등의 작업에 사용됩니다. 반면에 인터셉터는 주로 요청 전처리, 후처리, 로깅, 보안, 트랜잭션 관리 등의 작업에 사용됩니다.
둘 다 HTTP 요청과 응답을 가로채고 처리할 수 있는 기능을 제공하지만, 필터는 서블릿 컨테이너에 의해 관리되고 모든 서블릿에 공통적으로 적용될 수 있으며, 인터셉터는 주로 스프링 프레임워크에서 사용되며 DispatcherServlet에 의해 관리되고 컨트롤러의 호출 전후에 실행됩니다.

### 프레임워크(Framework)
프레임워크는 소프트웨어 개발을 위한 구조나 기반을 제공하는 추상화된 뼈대입니다. 개발자가 프레임워크를 사용하면 프로그램의 일부분을 작성하는 대신, 프레임워크가 제공하는 규칙과 기능을 따라 코드를 작성하게 됩니다.

### 특징
- 제어의 역전(Inversion of Control) 및 템플릿 메서드 패턴과 같은 디자인 패턴을 포함한 구조를 가집니다.
- 개발자가 프레임워크의 규칙에 따라 코드를 작성하고, 프레임워크가 애플리케이션의 실행 흐름을 제어합니다.
- 주로 애플리케이션의 구조를 정의하고 제어하기 위해 사용됩니다. 예를 들어 웹 프레임워크(Spring Framework, Django)는 웹 애플리케이션의 구조와 흐름을 제어하는 데 사용됩니다.

### 라이브러리(Library)
라이브러리는 재사용 가능한 코드 조각의 집합으로, 특정 기능을 수행하는 클래스, 함수 또는 모듈 등을 포함합니다. 라이브러리를 사용하면 개발자는 필요한 기능을 구현하기 위해 코드를 작성하고 호출할 수 있습니다.
### 특징
- 개발자가 필요한 기능을 수행하기 위해 라이브러리의 함수 또는 클래스를 호출합니다.
- 주로 특정 작업을 수행하기 위해 사용됩니다. 예를 들어 데이터베이스 연결을 위한 JDBC 라이브러리나 날짜 및 시간 처리를 위한 Java의 java.util.Date 클래스 등이 있습니다.
- 라이브러리는 개발자가 제어 흐름을 정의하는 데 사용되지 않으며, 호출되는 지점에서만 실행됩니다.

### 차이점
- **제어의 유무:** 프레임워크는 제어의 역전을 사용하여 애플리케이션의 실행 흐름을 제어하고, 개발자가 프레임워크의 규칙에 따라 코드를 작성합니다. 반면에 라이브러리는 개발자가 코드를 호출하여 필요한 기능을 사용하며, 제어의 역전을 사용하지 않습니다.
- **사용 목적:** 프레임워크는 애플리케이션의 구조를 정의하고 제어하는 데 사용되며, 일반적으로 애플리케이션의 전체 개발을 위해 사용됩니다. 라이브러리는 특정 작업을 수행하기 위해 필요한 기능을 제공하며, 개발자가 필요한 기능을 호출하여 사용합니다.


### RESTful 아키텍처(Representational State Transfer)
네트워크 기반의 소프트웨어 아키텍처 스타일 중 하나로, 분산 시스템에서 자원을 정의하고 관리하는 방법을 설명합니다. RESTful 아키텍처는 HTTP를 기반으로 하며, 리소스 간의 상호 작용을 간소화하고 표준화하는 데 목적이 있습니다.

### RESTful 아키텍처의 주요 특징과 개념
### 1.리소스(Resource)
- RESTful 아키텍처에서는 모든 자원을 리소스로 표현합니다. 예를 들어, 웹 서비스의 사용자, 주문, 제품 등은 각각의 리소스로 표현될 수 있습니다.
- 리소스는 고유한 식별자(URI)를 가지며, 클라이언트는 이 URI를 사용하여 리소스를 식별하고 액세스합니다.
### 2.HTTP 메서드
- HTTP 프로토콜의 다양한 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스에 대한 작업을 정의합니다.
- GET: 리소스를 조회합니다.
- POST: 새로운 리소스를 생성합니다.
- PUT: 기존의 리소스를 갱신하거나 새로운 리소스를 생성합니다.
- DELETE: 리소스를 삭제합니다.
### 3.표현(Representation)
- 리소스는 클라이언트에게 전달되는 표현을 가지고 있습니다. 일반적으로 JSON 또는 XML 형식으로 표현됩니다.
- 클라이언트와 서버 간의 통신은 이러한 표현을 통해 이루어집니다.
### 4.상태(Stateless)
- RESTful 아키텍처에서는 서버가 클라이언트의 상태를 관리하지 않습니다. 각각의 요청은 서로 독립적이며, 이전 요청과 관련된 상태 정보를 포함하지 않습니다.
- 이러한 상태 없음(Stateless)의 특성은 서버의 부하를 줄이고 확장성을 향상시킵니다.
### 5.유니폼 인터페이스(Uniform Interface)
- RESTful 아키텍처는 일관된 인터페이스를 제공하여 서버와 클라이언트 간의 통신을 단순화하고 표준화합니다.
- 이러한 인터페이스는 리소스 식별자, 리소스 상태의 표현, 자원 간의 상호 작용을 위한 하이퍼미디어 링크로 구성됩니다.
RESTful 아키텍처는 간단하고 확장 가능한 인터페이스를 제공하여 웹 서비스와 분산 시스템의 개발을 용이하게 합니다. 이는 HTTP 프로토콜의 강력한 특징과 함께 클라이언트와 서버 간의 상호 작용을 표준화하여 다양한 플랫폼 및 언어 간의 통신을 가능하게 합니다.

### 포워드 프록시 (Forward Proxy)
- 클라이언트와 인터넷 사이에 위치합니다.
- 클라이언트의 요청을 대신 받아 해당 요청을 서버로 전달하고, 받은 결과를 다시 클라이언트에게 전달합니다.
- 캐싱 기능을 사용하여 자주 사용되는 컨텐츠는 요청을 보내지 않고 캐시에서 가져올 수 있어 성능 향상이 가능합니다.
- IP 역추적을 방지할 수 있습니다.
### 리버스 프록시 (Reverse Proxy)
- 서버와 인터넷 사이에 위치합니다.
- 클라이언트가 인터넷을 통해 요청을 하면 내부 서버에서 요청을 받아 결과를 다시 클라이언트에게 전달합니다.
- 클라이언트는 내부 서버를 알 필요 없이 리버스 프록시에 요청만 하면 됩니다.
- 보안, 성능, 안정성 측면에서 장점이 있습니다. 리버스 프록시를 통해 웹 서버를 보다 안전하고 효율적으로 운영할 수 있습니다.
따라서, 포워드 프록시는 클라이언트 입장에서 클라이언트 요청을 대신 요청해주는 서버이며, 리버스 프록시는 서버의 입장에서 서버 대신 먼저 요청을 받아주는 서버입니다.

### SQL Injection
악의적인 사용자가 애플리케이션의 입력 폼 또는 매개변수에 SQL 쿼리를 삽입하여 데이터베이스에 대한 공격을 시도하는 보안 취약점입니다. 이 취약점을 이용하여 공격자는 데이터베이스에서 민감한 정보를 유출하거나 데이터베이스를 조작할 수 있습니다.

### SQL Injection 공격은 보통 다음과 같은 상황에서 발생할 수 있습니다.
- **입력 검증 부족:** 애플리케이션이 사용자 입력을 충분히 검증하지 않고 쿼리에 직접 삽입하는 경우 발생합니다.
- **동적 쿼리 구성:** 동적으로 SQL 쿼리를 생성할 때 사용자 입력 값을 직접 포함시키는 경우 발생합니다.
- **권한이 부여된 사용자:** 공격자가 악의적인 SQL 쿼리를 실행할 수 있는 권한이 있는 사용자 인터페이스에 접근할 수 있는 경우 발생합니다.

### SQL Injection 공격을 통해 공격자는 다음과 같은 악의적인 행동을 수행할 수 있습니다.
- **데이터베이스 정보 유출:** 공격자는 SQL Injection을 통해 데이터베이스의 내용을 유출할 수 있습니다. 이는 사용자의 개인정보, 인증 정보 등을 포함할 수 있습니다.
- **데이터베이스 수정:** 공격자는 SQL Injection을 사용하여 데이터베이스의 내용을 수정하거나 삭제할 수 있습니다. 이는 데이터의 손상이나 유실을 초래할 수 있습니다.
- **관리자 권한 탈취:** 공격자는 SQL Injection을 통해 관리자 계정을 탈취하거나, 데이터베이스에 대한 완전한 제어권을 얻을 수 있습니다.

### SQL Injection 공격으로부터 보호하기 위한 주요 방법은 다음과 같습니다.
- **매개변수화된 쿼리 사용:** 사용자 입력 값을 직접 쿼리에 삽입하지 말고, 매개변수화된 쿼리를 사용하여 입력 값을 분리하고 처리합니다.
- **입력 검증:** 사용자 입력을 검증하여 예상치 않은 값이나 형식을 거부합니다.
- **최소 권한 원칙:** 데이터베이스 접근 권한을 최소한으로 제공하여 공격자가 데이터베이스에 접근하는 것을 방지합니다.
- **보안 정책 강화:** 데이터베이스 접근에 대한 강력한 보안 정책을 시행하여 민감한 작업을 수행하는 사용자에 대한 제한을 설정합니다.
- **보안 감사 및 모니터링:** 시스템에서 발생하는 모든 SQL 쿼리를 감사하고 모니터링하여 악의적인 활동을 식별하고 대응합니다.

### OAuth(Open Authorization
웹 및 모바일 애플리케이션에서 안전하고 표준화된 방법으로 사용자 인증 및 권한 부여를 수행하기 위한 프로토콜 및 인증 표준입니다. OAuth는 서드 파티 애플리케이션이 인증 서버의 사용자 데이터에 접근할 수 있는 권한을 부여하는 데 사용됩니다. 주로 사용자가 다른 서비스의 계정을 사용하여 애플리케이션에 로그인할 때 사용됩니다.

### OAuth는 다음과 같은 주요 구성 요소
#### 1.Resource Owner (리소스 소유자)
리소스 소유자는 액세스 허가가 필요한 보호 자원에 대한 액세스를 제어하는 사용자입니다. 일반적으로 이는 애플리케이션 사용자를 의미합니다.
#### 2.Client (클라이언트)
클라이언트는 리소스에 액세스하려는 애플리케이션이나 서비스를 나타냅니다. 클라이언트는 리소스 소유자의 권한을 대신하여 서버에 요청을 보냅니다.
#### 3.Authorization Server (인증 서버)
인증 서버는 클라이언트 애플리케이션에 대한 인증 및 권한 부여를 담당합니다. 리소스 소유자가 클라이언트에 대한 액세스를 승인하면 인증 서버는 액세스 토큰을 발급합니다.
#### 4.Resource Server (리소스 서버)
리소스 서버는 보호된 리소스에 대한 실제 액세스를 제공하는 서버입니다. 클라이언트가 액세스 토큰을 사용하여 리소스에 대한 요청을 보낼 때 리소스 서버는 요청을 검증하고 해당 리소스에 대한 액세스 권한을 확인합니다.

### OAuth 프로토콜은 다양한 인증 방법을 지원하며, 주요한 인증 흐름(Flows)에는 다음과 같은 것들이 있습니다.
- **Authorization Code Flow:** 웹 애플리케이션에서 사용되며, 클라이언트가 인증 코드를 얻고 이를 사용하여 액세스 토큰을 요청하는 방식입니다.
- **Implicit Flow:** 클라이언트에서 사용자에게 직접 리디렉션되는 방식으로, 액세스 토큰을 직접 반환합니다. 주로 JavaScript 애플리케이션에서 사용됩니다.
- **Resource Owner Password Credentials Flow:** 리소스 소유자의 사용자 이름과 암호를 사용하여 직접 액세스 토큰을 요청하는 방식입니다.
- **Client Credentials Flow:** 클라이언트가 자신의 인증 정보를 사용하여 액세스 토큰을 요청하는 방식으로, 주로 서버 간 통신에서 사용됩니다.
OAuth는 강력한 보안 기능과 표준화된 프로토콜을 제공하여 다양한 애플리케이션에서 사용자 인증 및 권한 부여를 안전하고 효율적으로 처리할 수 있도록 도와줍니다

### JWT( JSON Web Token)
웹 표준(RFC 7519)으로서 두 개체 간에 JSON 객체를 안전하게 전송하기 위한 콤팩트하고 자체적으로 무결성을 검증할 수 있는 방식을 정의합니다. 일반적으로 클라이언트와 서버 간의 인증을 위해 사용됩니다.

### JWT는 세 부분으로 구성됩니다.
- **Header(헤더):** 토큰의 유형 및 해싱 알고리즘과 같은 메타데이터를 포함합니다. 예를 들어, "alg"라는 키를 사용하여 토큰에 적용된 암호화 알고리즘을 지정합니다.
- **Payload(내용):** 토큰에 포함될 클레임(Claim) 정보를 포함합니다. 클레임은 사용자에 대한 정보(주로 ID)나 추가 데이터를 나타내며, 서버가 해당 정보를 사용하여 인증 및 권한 부여를 수행합니다. 클레임은 등록(Claims Registered) 클레임, 공개(Public) 클레임, 비공개(Private) 클레임으로 나뉩니다.
- **Signature(서명):** 서명은 헤더와 페이로드를 결합하여 생성된 것으로, 토큰의 무결성을 확인하기 위한 것입니다. 서명은 암호화된 헤더와 페이로드, 그리고 서버의 비밀 키를 사용하여 생성됩니다.

### JWT의 주요 특징
- **자가 수용적(Self-contained):** JWT는 필요한 모든 정보를 자체적으로 포함하고 있으므로, 추가적인 데이터베이스 조회 없이도 클라이언트와 서버 간의 통신이 가능합니다.
- **스테이트리스(Stateless):** 서버는 클라이언트의 상태를 유지하지 않으므로, 클라이언트가 토큰을 포함하여 요청할 때마다 서버는 필요한 인증 및 권한 부여를 수행합니다.
- **보안성(Security):** JWT의 서명을 통해 토큰의 무결성을 보장하고, 암호화를 사용하여 토큰 내의 클레임 정보를 안전하게 전송할 수 있습니다.
- **유연성(Flexibility):** JWT는 다양한 클레임 정보를 포함할 수 있으며, 사용자 정의 클레임을 추가하여 필요한 정보를 포함할 수 있습니다.
JWT는 클라이언트와 서버 간의 효율적인 통신을 위해 널리 사용되며, 웹 및 모바일 애플리케이션에서 인증 및 권한 부여에 주로 활용됩니다.




























