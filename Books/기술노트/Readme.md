## 프로세스와 스레드
### 프로세스
- **정의:** 프로세스는 운영 체제에서 실행되는 프로그램의 인스턴스입니다. 각 프로세스는 독립된 메모리 공간을 가지며, 실행 중인 프로그램의 상태를 나타냅니다.
- **메모리 공유:** 각 프로세스는 독립된 메모리 공간을 가지므로, 서로 다른 프로세스 간에는 메모리를 공유하지 않습니다.
- **생성 속도:** 프로세스 생성에는 많은 비용이 소요됩니다. 새로운 프로세스를 생성할 때는 프로세스의 복사본을 만들어야 하므로 시간과 자원이 많이 필요합니다.
- **스위칭 비용:** 프로세스 간의 전환은 컨텍스트 스위칭이 필요하며, 이는 비용이 많이 듭니다. 각 프로세스는 독립된 메모리 공간을 가지고 있기 때문에 전환 시 메모리 매핑과 상태 저장 등의 작업이 필요합니다.

### 스레드
- **정의:** 스레드는 프로세스 내에서 실행되는 작은 실행 단위입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다.
- **메모리 공유:** 스레드는 같은 프로세스 내에서 실행되므로, 프로세스의 메모리를 공유합니다. 이는 데이터를 공유하고 효율적인 통신을 가능케 합니다.
- **생성 속도:** 스레드는 프로세스 내에서 생성되며, 프로세스의 자원을 공유하기 때문에 스레드를 생성하는 데 필요한 비용이 적습니다.
- **스위칭 비용:** 스레드 간의 전환은 상대적으로 더 빠르며 경량입니다. 스레드는 같은 프로세스 내에서 실행되므로, 전환 시에는 스택과 레지스터 값만 변경하면 되므로 프로세스 전환보다 적은 비용이 듭니다.

## 동시성과 병렬성
### 동시성(Concurrency)
- **정의:** 동시성은 여러 작업이 동시에 진행되는 것처럼 보이는 개념을 나타냅니다. 실제로는 여러 작업이 동시에 실행되는 것이 아니라, 작업 간의 빠른 전환을 통해 동시에 실행되는 것처럼 보입니다.
- **예시:** 다중 프로세스 또는 다중 스레드를 사용하여 여러 작업을 동시에 처리할 수 있습니다. 예를 들어, 웹 서버는 여러 클라이언트 요청을 동시에 처리하기 위해 다중 스레드를 사용할 수 있습니다.
- **주요 특징:**
  - 동시성은 시스템의 반응성을 향상시키고 작업 처리량을 증가시킬 수 있습니다.
  - 다양한 동기화 기술을 사용하여 공유 자원에 대한 안전한 접근을 보장해야 합니다.

### 병렬성(Parallelism)
- **정의:** 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 나타냅니다. 하나의 작업을 여러 개의 하위 작업으로 분할하고, 이를 동시에 처리함으로써 병렬성을 달성할 수 있습니다.
- **예시:** 멀티코어 프로세서를 사용하여 하나의 프로그램을 동시에 여러 개의 스레드로 실행하거나, 여러 대의 컴퓨터를 클러스터로 구성하여 작업을 분산하는 등의 방법으로 병렬성을 달성할 수 있습니다.
- **주요 특징:**
  - 병렬성은 작업을 동시에 실행함으로써 처리 시간을 단축하고 성능을 향상시킬 수 있습니다.
  - 공유 자원에 대한 경합 상태나 동기화 문제를 피하기 위해 조심해야 합니다.

### 요약
- 동시성은 여러 작업을 동시에 실행되는 것처럼 보이게 만들어 시스템의 반응성을 향상시키고 처리량을 증가시킵니다.
- 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 나타내며, 처리 시간을 단축하고 성능을 향상시킵니다.
- 동시성과 병렬성은 서로 다른 개념이지만, 종종 함께 사용되어 병렬화된 동시성(concurrent parallelism)을 구현하는 데 사용됩니다.

## 데드락(Deadlock)
멀티스레드 또는 멀티프로세스 환경에서 발생하는 중요한 문제 중 하나입니다. 데드락은 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리며 진행하지 못하는 상태를 말합니다. 이러한 상황에서는 각 작업이 다른 작업이 끝나기를 기다리면서 서로를 블록시키고 있어, 시스템이 더 이상 진행할 수 없게 됩니다.

### 데드락 발생 4가지 조건
- **상호 배제(Mutual Exclusion):** 리소스에 대한 동시 접근이 허용되지 않아야 합니다. 즉, 한 번에 하나의 프로세스만 리소스에 접근할 수 있어야 합니다.
- **보유 및 대기(Hold and Wait):** 프로세스가 이미 어떤 리소스를 보유한 상태에서 다른 리소스를 얻기 위해 대기하는 경우입니다.
- **비선점(No Preemption):** 어떤 프로세스가 이미 어떤 리소스를 보유하고 있을 때, 그 리소스를 다른 프로세스가 선점할 수 없어야 합니다. 리소스는 해당 프로세스가 자발적으로 릴리스할 때만 다른 프로세스에게 넘어갑니다.
- **순환 대기(Circular Wait):** 프로세스 집합 {P1, P2, ..., Pn}에서, P1은 P2가 보유한 리소스를 대기하고, P2는 P3가 보유한 리소스를 대기하는 식으로, Pn은 P1이 보유한 리소스를 대기하는 상황입니다.

### 데드락을 방지하거나 해결하기 위한 전략
- **상호 배제를 해제:** 리소스에 대한 동시 접근을 허용하거나, 특정 조건에서만 상호 배제를 적용합니다. 이 방법은 데드락을 방지할 수 있지만, 다른 문제를 야기할 수도 있습니다.
- **보유 및 대기를 방지:** 프로세스가 모든 필요한 리소스를 한 번에 얻을 수 있도록 설계합니다. 이를 위해 리소스를 예약하거나, 리소스를 보유하지 않은 상태에서 다른 리소스를 요청할 수 있도록 하는 등의 방법을 사용할 수 있습니다.
- **비선점:** 리소스 선점 기능을 추가하여, 다른 프로세스가 필요한 리소스를 강제로 빼앗을 수 있도록 합니다. 이는 일부 시스템에서는 적용하기 어려울 수 있습니다.
- **순환 대기 방지:** 리소스 요청 순서를 정하여 순환 대기를 방지하거나, 리소스를 할당할 때 우선순위를 부여하여 순환 대기를 예방할 수 있습니다.

## 트랜잭션 격리 레벨
트랜잭션 격리 레벨은 동시에 여러 트랜잭션이 발생할 때 데이터베이스 시스템에서 트랜잭션 간의 상호 작용을 제어하는 방법을 나타냅니다. 데이터베이스에서 일반적으로 네 가지 격리 레벨이 정의되어 있습니다. 각 레벨은 트랜잭션 간의 일관성, 격리 수준, 성능 등을 다르게 보장합니다. 이러한 격리 레벨은 ANSI/ISO SQL 표준에 따라 정의되며, 다음과 같습니다:

### Read Uncommitted (미커밋 읽기)
- 가장 낮은 격리 레벨로, 다른 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있습니다.
- 이 격리 레벨에서는 Dirty Read(더티 리드), Non-Repeatable Read(반복되지 않는 읽기), Phantom Read(유령 읽기)와 같은 문제가 발생할 수 있습니다.

### Read Committed (커밋된 읽기) - Oracle, MsSQL
- 트랜잭션이 커밋된 데이터만 읽을 수 있습니다. 이러한 레벨에서는 Dirty Read는 방지됩니다.
- 하지만 Non-Repeatable Read와 Phantom Read는 발생할 수 있습니다.

### Repeatable Read (반복 가능한 읽기) - MySQL
- 트랜잭션 내에서 동일한 쿼리를 여러 번 실행하더라도 항상 동일한 결과가 나타납니다. 즉, 다른 트랜잭션이 해당 트랜잭션의 데이터를 변경할 수 없습니다.
- 이 격리 레벨에서는 Dirty Read와 Non-Repeatable Read는 방지됩니다. 하지만 Phantom Read는 발생할 수 있습니다.

### Serializable (직렬화 가능)
- 가장 높은 격리 레벨로, 동시성을 완전히 차단하여 동시에 두 개 이상의 트랜잭션이 실행되지 않습니다.
- 이 격리 레벨에서는 Dirty Read, Non-Repeatable Read, Phantom Read가 모두 방지됩니다.

데이터베이스 시스템에서는 이러한 격리 레벨 중 하나를 선택하여 트랜잭션의 일관성과 동시성을 적절히 조절합니다. 레벨을 선택할 때는 데이터베이스 시스템의 요구 사항, 데이터 무결성, 일관성, 성능 등을 고려해야 합니다. 더 높은 격리 레벨은 데이터 무결성을 보다 확실히 보장하지만, 동시성에 대한 성능 저하가 발생할 수 있습니다.

## 트랜잭션 락(Transaction Lock)
데이터베이스 트랜잭션이 데이터에 대한 액세스를 제어하는 메커니즘입니다. 트랜잭션 락은 다른 트랜잭션이 동시에 동일한 데이터를 수정하거나 액세스하지 못하도록 보장하여 데이터의 일관성과 무결성을 유지합니다.

### 트랜잭션 락 종류
- **읽기 락(Read Lock):** 트랜잭션이 데이터를 읽을 때 사용됩니다. 읽기 락이 설정되어 있으면 다른 트랜잭션은 해당 데이터를 수정할 수 없습니다. 여러 트랜잭션이 동시에 동일한 데이터를 읽을 수 있습니다.
- **쓰기 락(Write Lock):** 트랜잭션이 데이터를 수정할 때 사용됩니다. 쓰기 락이 설정되어 있으면 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없습니다. 여러 트랜잭션이 동시에 동일한 데이터를 수정할 수 없습니다.
- **공유 락(Shared Lock):** 여러 트랜잭션이 동시에 데이터를 읽을 수 있지만, 쓰기 락을 설정한 트랜잭션이 존재하면 쓰기 락이 해제될 때까지 데이터를 수정할 수 없습니다.
- **배타적 락(Exclusive Lock):** 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션은 해당 데이터를 읽거나 수정할 수 없습니다.
데이터베이스 시스템은 이러한 락을 사용하여 동시성 제어를 관리합니다. 트랜잭션은 데이터를 액세스하기 전에 해당 데이터에 대한 적절한 락을 얻어야 합니다. 만약 다른 트랜잭션이 이미 해당 데이터에 대한 락을 보유하고 있다면, 트랜잭션은 락이 해제될 때까지 대기하게 됩니다. 이를 통해 데이터베이스 시스템은 여러 트랜잭션이 동시에 데이터를 수정할 때 발생할 수 있는 일관성과 무결성 문제를 방지합니다.

### DROP
- **정의:** DROP 문은 테이블 자체를 삭제하는 데 사용됩니다. 즉, 테이블의 구조와 함께 테이블의 모든 데이터가 삭제됩니다.
- **영향:** DROP 문을 사용하면 테이블과 그 안의 모든 데이터가 영구적으로 삭제됩니다. 데이터베이스에서 테이블이 완전히 사라지게 됩니다.
- **롤백:** DROP 문은 롤백되지 않습니다. 즉, 트랜잭션이 롤백되더라도 테이블이 삭제된 상태로 남아 있습니다.

### TRUNCATE
- **정의:** TRUNCATE 문은 테이블의 모든 데이터를 삭제하지만, 테이블의 구조는 유지됩니다.
- **영향:** TRUNCATE 문을 사용하면 테이블의 모든 데이터가 삭제되지만, 테이블 자체는 남아 있습니다.
- **롤백:** TRUNCATE 문은 롤백될 수 있습니다. 트랜잭션이 롤백되면 TRUNCATE된 데이터가 복구됩니다. 하지만 몇몇 데이터베이스 관리 시스템에서는 롤백이 지원되지 않을 수도 있습니다.

`DROP`은 테이블 자체를 삭제하고 그 안의 모든 데이터를 삭제합니다. 테이블 자체가 완전히 사라지며 롤백되지 않습니다.
`TRUNCATE`는 테이블의 데이터를 삭제하지만, 테이블 자체는 유지됩니다. 롤백될 수 있으며, 롤백 시 삭제된 데이터가 복구될 수 있습니다.

## JPA(Java Persistence API) 1차 캐시(First Level Cache)와 2차 캐시(Second Level Cache)
### 1차 캐시(First Level Cache)
- **정의:** 1차 캐시는 엔티티 매니저 내에 존재하는 캐시로, 엔티티 매니저가 특정 트랜잭션 내에서 관리하는 영역입니다. 각각의 엔티티 매니저 인스턴스마다 독립적으로 관리되며, 특정 엔티티 매니저가 로드한 엔티티는 해당 엔티티 매니저 내에서 캐시됩니다.
- **스코프:** 엔티티 매니저의 트랜잭션 범위 내에서만 유효합니다. 트랜잭션이 커밋되거나 롤백되면 1차 캐시도 함께 비워집니다.
- **장점:** 같은 트랜잭션 내에서 같은 엔티티를 여러 번 조회할 경우, 1차 캐시에서 해당 엔티티를 바로 반환하여 데이터베이스에 추가적인 조회를 하지 않아도 됩니다.

### 2차 캐시(Second Level Cache)
- **정의:** 2차 캐시는 여러 엔티티 매니저 간에 공유되는 캐시로, 여러 트랜잭션 또는 엔티티 매니저 간에 공유할 수 있습니다. 따라서 2차 캐시에 저장된 엔티티는 여러 엔티티 매니저 간에 공유되어 조회될 수 있습니다.
- **스코프:** 애플리케이션 전체에서 유효합니다. 엔티티 매니저 간에 공유되므로 같은 엔티티가 여러 번 로드되더라도 데이터베이스에 추가적인 조회를 하지 않을 수 있습니다.
- **장점:** 네트워크 오버헤드를 줄일 수 있으며, 동일한 엔티티를 여러 번 조회할 때 쿼리를 다시 실행하지 않고 캐시된 엔티티를 반환하여 성능을 향상시킵니다.

### 요약
- 1차 캐시는 엔티티 매니저의 트랜잭션 범위 내에서 동작하며, 엔티티 매니저 간에 공유되지 않습니다.
- 2차 캐시는 애플리케이션 전체에서 동작하며, 여러 엔티티 매니저 간에 공유됩니다. 따라서 네트워크 오버헤드를 줄이고 성능을 향상시킬 수 있습니다.

## OSIV(Open Session In View)
JPA(Java Persistence API)를 사용하는 웹 애플리케이션에서 사용되는 패턴입니다. OSIV 패턴은 HTTP 요청의 라이프사이클 동안 JPA 세션(또는 엔티티 매니저)을 열어두고, 뷰 렌더링까지 세션을 유지하는 방식입니다.

일반적으로 웹 애플리케이션에서는 HTTP 요청이 발생하면 해당 요청을 처리하기 위한 JPA 세션이 열리고, 요청이 완료되면 세션이 닫히는 것이 보통입니다. 그러나 OSIV 패턴을 사용하면 HTTP 요청의 처리 과정 동안 JPA 세션이 유지되어, 해당 요청에서 발생한 엔티티의 로딩과 관련된 모든 작업을 수행할 수 있습니다.

### OSIV 패턴의 주요 특징
- **지연로딩(Lazy Loading) 사용:** OSIV 패턴을 사용하면 뷰 렌더링 단계에서도 엔티티를 로딩할 수 있습니다. 이는 지연로딩이 사용되는 경우에도 뷰에서 필요한 엔티티를 로딩할 수 있게 해줍니다.
- **트랜잭션 범위 확장:** 일반적으로 JPA 세션은 트랜잭션 범위 내에서만 유효하지만, OSIV 패턴을 사용하면 HTTP 요청의 전체 라이프사이클 동안 세션을 유지할 수 있습니다.
- **View와 로직의 분리 유지:** OSIV 패턴을 사용하면 뷰 렌더링 과정에서도 엔티티를 로딩할 수 있으므로, View와 비즈니스 로직을 명확하게 분리할 수 있습니다.
- 
OSIV 패턴은 편리하게 사용할 수 있지만, 신중하게 사용해야 합니다. 잘못 사용하면 지연로딩을 트랜잭션 밖에서 수행하게 되어 LazyInitializationException과 같은 문제가 발생할 수 있습니다. 또한 OSIV 패턴은 세션을 오래 유지하기 때문에 메모리 누수와 같은 부작용이 발생할 수 있으므로 주의가 필요합니다.

## N+1 문제
부모 엔티티들을 가져온 후, 각각의 부모 엔티티에 대해 추가적인 쿼리를 실행하여 연관된 자식 엔티티를 로딩합니다. 이 때, 각 부모 엔티티당 하나의 쿼리가 추가로 실행됩니다. 이 때문에 "N+1"이라는 용어가 사용됩니다.
이러한 N+1 문제는 다음과 같은 상황에서 특히 빈번하게 발생할 수 있습니다.

- 연관된 엔티티를 지연 로딩으로 설정한 경우
- 엔티티 그래프 또는 패치 조인(fetch join)을 사용하지 않고 연관된 엔티티를 로딩하는 경우
- 엔티티 그래프나 패치 조인을 사용했지만, 그것이 올바르게 설정되지 않은 경우

### N+1 문제를 해결하기 위한 몇 가지 방법
- 엔티티 그래프 또는 패치 조인 사용: 엔티티 그래프나 패치 조인을 사용하여 쿼리를 통해 한 번에 연관된 엔티티를 함께 로딩할 수 있습니다. 이를 통해 추가적인 쿼리 실행 없이 모든 데이터를 한 번에 가져올 수 있습니다.
- 일괄 로딩(Batch Loading) 사용: 일괄 로딩은 일괄 처리 방식으로 데이터를 가져오는 기능입니다. 이를 통해 여러 엔티티를 한 번에 로딩하여 N+1 문제를 방지할 수 있습니다.
- 캐시 사용: 캐시를 사용하여 자주 사용되는 데이터를 메모리에 저장하여 추가적인 쿼리를 방지할 수 있습니다. 하지만 이 방법은 캐시의 유효성과 관리에 주의해야 합니다.


