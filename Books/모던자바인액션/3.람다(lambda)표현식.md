### 람다 표현식
람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

### 람다의 특징
- 익명: 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다.
- 함수: 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처러 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.
- 전달: 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성: 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

### 간결한 코드와 유연성
#### Comparator 예제
```java
Comparator<Apple> byWeight = new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
};
```

다음은 람다를 이용한 코드다.
```java
Comparator<Apple> byWeight = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

### 3.2.1 함수형 인터페이스
2장에서 만든 Predicate<T>가 함수형 인터페이스다. Predicate<T>는 오직 하나의 추상 메서드만 지정하기 때문이다.
```java
public interface Predicate<T> {
  boolean test(T t);
}
```

즉, 함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다. `Comparator`, `Runnable`도 자바 API의 함수형 인터페이스다.
```java
public interface Comparator<T> {
  int compare(T o1, T o2);
}
```

```java
public interface Runnable {
  void run();
}
```

#### 📌 인터페이스는 디폴트 메서드를 포함할 수 있다. 많은 디폴트 메서드가 있더라도 추상 메서드가 오직 하나면 함수형 인터페이스다.

### 3.2.2 함수 디스크립터
함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.

예를 들어 Runnable 인터페이스의 유일한 추상 메서드 run은 인수와 반환값이 없으므로(void 반환) Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.

#### 왜 함수형 인터페이스를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있을까? 라는 의문이 생길 수 있다.
- 언어 설계자들은 자바에 함수형식을 추가하는 방법도 대안으로 고려했다.
- 자바 프로그래머가 하나의 추상 메서드를 갖는 인터페이스(예를 들면 이벤트 처리 인터페이스)에 이미 익숙하다는 점을 고려했다.
  
#### @FunctionalInterface
새로운 자바 API를 살펴보면 함수형 인터페이스에 @FunctionalInterface 어노테이션이 추가되어 있다. 이는 함수형 인터페이스를 가리키는 어노테이션이다. @FunctionalInterface로 인터페이스를 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다. 예를 들어 추상 메서드가 한 개 이상이라면 `"Multiple nonoverriding abstract methods found in interface Foo(인터페이스 Foo에 오버라이드 하지 않은 여러 추상 메서드가 있음)"` 같은 에러가 발생할 수 있다.













